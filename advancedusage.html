<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Advanced usage &mdash; fmu-ensemble 1.6.9 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=d749edf1"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="API for fmu.ensemble" href="modules.html" />
    <link rel="prev" title="Concepts in fmu-ensemble" href="concepts.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            fmu-ensemble
              <img src="_static/equinor-logo2.jpg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.6.9
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="readme.html">Introduction to <em>FMU Ensemble</em></a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="concepts.html">Concepts in fmu-ensemble</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Advanced usage</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#merging-data">Merging data</a></li>
<li class="toctree-l2"><a class="reference internal" href="#statistics-over-ensembles">Statistics over ensembles</a></li>
<li class="toctree-l2"><a class="reference internal" href="#comparing-realizations-or-ensembles">Comparing realizations or ensembles</a></li>
<li class="toctree-l2"><a class="reference internal" href="#working-with-observations">Working with observations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#representative-realizations">Representative realizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#custom-compute-functions-for-each-realization">Custom compute functions for each realization</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="modules.html">API for fmu.ensemble</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="authors.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="history.html">History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">fmu-ensemble</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Advanced usage</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/advancedusage.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="advanced-usage">
<h1>Advanced usage<a class="headerlink" href="#advanced-usage" title="Permalink to this heading"></a></h1>
<section id="merging-data">
<h2>Merging data<a class="headerlink" href="#merging-data" title="Permalink to this heading"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">CSV_EXPORT1</span></code> workflow built into ERT is performing one of the
specific tasks that can now be accomplished using this module. That
CSV export is just a merge of the dataframes coming from
<code class="docutils literal notranslate"><span class="pre">parameters.txt</span></code> and the Eclipse summary data.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="n">smry</span> <span class="o">=</span> <span class="n">reekensemble</span><span class="o">.</span><span class="n">load_smry</span><span class="p">(</span><span class="n">time_index</span><span class="o">=</span><span class="s1">&#39;monthly&#39;</span><span class="p">)</span>
<span class="n">params</span> <span class="o">=</span> <span class="n">reekensemble</span><span class="o">.</span><span class="n">parameters</span>
<span class="c1"># Match the two tables where the value of REAL is identical:</span>
<span class="n">smry_params</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">smry</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
<span class="n">smry_params</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s1">&#39;smry_params.csv&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>For finer control, you can specify exactly which summary vectors you
want to include, the time resolution, and perhaps also a subset of the
parameters. For example, if you have computed any kind of scalar data
pr. realization and put that into <code class="docutils literal notranslate"><span class="pre">outputs.txt</span></code>, you can merge with
<code class="docutils literal notranslate"><span class="pre">load_txt('outputs.txt')</span></code> instead of <code class="docutils literal notranslate"><span class="pre">params</span></code> in the code above.</p>
</section>
<section id="statistics-over-ensembles">
<h2>Statistics over ensembles<a class="headerlink" href="#statistics-over-ensembles" title="Permalink to this heading"></a></h2>
<p>Statistics over ensembles can be computed by aggregating their data
and presenting them in realization-like objects. A “<em>mean</em>” of an
ensemble is possible to compute for all data an ensemble contains, and
the result is something that we treat like a <em>realization</em>. It is
important to realize that this result is <strong>not</strong> a realization, only
something we can treat in this way, for which the <code class="docutils literal notranslate"><span class="pre">VirtualRealization</span></code>
object is used. This “mean realization” is not a physical realization
where all numbers make physically sense, it just gives you the mean of
all the data, over the realizations for scalars, for each point in
time for time-series.</p>
<p>As an example, oil, gas, and pressure profiles in a statistical
realization, will typically not be compatible, in that it can be
physically impossible in reality to obtain these profiles. Use
and interpret with care!</p>
<p>Supported statistical aggregations are <code class="docutils literal notranslate"><span class="pre">mean</span></code>, <code class="docutils literal notranslate"><span class="pre">median</span></code>, <code class="docutils literal notranslate"><span class="pre">min</span></code>,
<code class="docutils literal notranslate"><span class="pre">max</span></code>, <code class="docutils literal notranslate"><span class="pre">std</span></code>, <code class="docutils literal notranslate"><span class="pre">var</span></code> and <code class="docutils literal notranslate"><span class="pre">pXX</span></code> where <code class="docutils literal notranslate"><span class="pre">XX</span></code> is a number between
<code class="docutils literal notranslate"><span class="pre">00</span></code> and <code class="docutils literal notranslate"><span class="pre">99</span></code> being the percentile you want. You access this
functionality through the function <code class="docutils literal notranslate"><span class="pre">agg()</span></code> in the ensemble objects.</p>
<p>Pandas and Numpy is used under the hood for all computations. The quantile
integers you supply are forwarded directly to Pandas, beware that this
is opposite to the usual subsurface understanding of e.g. a “high case
p10 profile”. Translate p10 to p90 if needed in your client code.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ens</span> <span class="o">=</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">ScratchEnsemble</span><span class="p">(</span><span class="s1">&#39;ref-ensemble&#39;</span><span class="p">,</span>
         <span class="s1">&#39;/scratch/foo/r018-ref-case/realization-*/iter-3&#39;</span><span class="p">)</span>

<span class="n">mean</span> <span class="o">=</span> <span class="n">ens</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>

<span class="c1"># What is the mean value of &quot;FWL&quot; in parameters.txt?</span>
<span class="nb">print</span><span class="p">(</span><span class="n">mean</span><span class="p">[</span><span class="s1">&#39;parameters.txt&#39;</span><span class="p">][</span><span class="s1">&#39;FWL&#39;</span><span class="p">])</span>

<span class="c1"># What is the mean ultimate FOPT</span>
<span class="nb">print</span><span class="p">(</span><span class="n">mean</span><span class="p">[</span><span class="s1">&#39;unsmry--monthly&#39;</span><span class="p">][</span><span class="s1">&#39;FOPT&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="c1"># (.iloc[-1] is here Pandas functionality for accessing the last</span>
<span class="c1"># row)</span>
</pre></div>
</div>
</section>
<section id="comparing-realizations-or-ensembles">
<h2>Comparing realizations or ensembles<a class="headerlink" href="#comparing-realizations-or-ensembles" title="Permalink to this heading"></a></h2>
<p>Any linear combination of ensembles or realizations is possible to
compute, in a pointwise manner. This includes the data that is shared
in the linear combination.</p>
<p>Computing the sum of two realizations is only a matter of adding them
in your Python interpreter. The end result is a object you can treat
similar to a realization, asking for its data using <code class="docutils literal notranslate"><span class="pre">get_df()</span></code>, or
asking for the summary data using <code class="docutils literal notranslate"><span class="pre">get_smry()</span></code>. Eclipse time-series
will be combined at point-wise in time, but only on shared
time-steps. It is therefore recommended to interpolate them to
e.g. monthly time interval prior to combination.</p>
<p>Ensembles can be linearly combined analogously to realizations, and
will be matched on realization index <code class="docutils literal notranslate"><span class="pre">REAL</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">refens</span> <span class="o">=</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">ScratchEnsemble</span><span class="p">(</span><span class="s1">&#39;ref-ensemble&#39;</span><span class="p">,</span>
            <span class="s1">&#39;/scratch/foo/r018-ref-case/realization-*/iter-3&#39;</span><span class="p">)</span>
<span class="n">iorens</span> <span class="o">=</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">ScratchEnsemble</span><span class="p">(</span><span class="s1">&#39;ior-ensemble&#39;</span><span class="p">,</span>
            <span class="s1">&#39;/scratch/foo/r018-ior-case/realization-*/pred&#39;</span><span class="p">)</span>

<span class="c1"># Calculate the delta ensemble</span>
<span class="n">deltaens</span> <span class="o">=</span> <span class="n">iorens</span> <span class="o">-</span> <span class="n">refens</span>

<span class="c1"># Obtain the field gain:</span>
<span class="n">fieldgain</span> <span class="o">=</span> <span class="n">deltaens</span><span class="o">.</span><span class="n">get_smry</span><span class="p">(</span><span class="n">column_keys</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;FOPT&#39;</span><span class="p">],</span>
                              <span class="n">time_index</span><span class="o">=</span><span class="s1">&#39;monthly&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>If the ensembles you want to combine cannot be compared realization by
realization, or does not even contain the same number of realizations,
you should first aggregate the ensembles (mean or anyone else), and
then construct delta objects of the statistical realizations.</p>
<p>Remember that this library does not help you in interpreting these
results correctly, it only gives you the opportunity to calculate them!</p>
</section>
<section id="working-with-observations">
<h2>Working with observations<a class="headerlink" href="#working-with-observations" title="Permalink to this heading"></a></h2>
<p>Observations for history matching can be loaded, and computations
(comparisons) of observed data versus simulated data can be performed.</p>
<p>The Observation object can be initizalized using YAML files or from
a Python dictionary.</p>
<p>If you are opting for simple usage, just being able to compare <code class="docutils literal notranslate"><span class="pre">FOPT</span></code>
versus <code class="docutils literal notranslate"><span class="pre">FOPTH</span></code> in your ensemble, your observation config could look
like:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="c1"># Eclipse summary vectors compared with allocated summary vectors</span>
<span class="nt">smryh</span><span class="p">:</span>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">key</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">FOPT</span>
<span class="w">    </span><span class="nt">histvec</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">FOPTH</span>
<span class="w">    </span><span class="nt">time_index</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">monthly</span><span class="w">  </span><span class="c1"># or yearly, daily, raw or last, or a ISO-date</span>
</pre></div>
</div>
<p>This file can be loaded in Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Assume the yaml above has been put in a file:</span>
<span class="n">obs</span> <span class="o">=</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">Observations</span><span class="p">(</span><span class="s1">&#39;fopt-obs.yml&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively, it is possible to initialize this directly without the filesystem:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">obs</span> <span class="o">=</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">Observations</span><span class="p">({</span><span class="s1">&#39;smryh&#39;</span><span class="p">:</span> <span class="p">[{</span><span class="s1">&#39;key&#39;</span><span class="p">:</span> <span class="s1">&#39;FOPT&#39;</span><span class="p">,</span>
        <span class="s1">&#39;histvec&#39;</span><span class="p">:</span> <span class="s1">&#39;FOPTH&#39;</span><span class="p">,</span> <span class="s1">&#39;time_index&#39;</span><span class="p">:</span> <span class="s1">&#39;last&#39;</span><span class="p">}]})</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load an ensemble we want to analyze</span>
<span class="n">ens</span> <span class="o">=</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">ScratchEnsemble</span><span class="p">(</span><span class="s1">&#39;hmcandidate&#39;</span><span class="p">,</span>
        <span class="s1">&#39;/scratch/foo/something/realization-*/iter-3&#39;</span><span class="p">)</span>

<span class="c1"># Perform calculation of misfit</span>
<span class="c1"># A dataframe with computed mismatches is returned.</span>
<span class="c1"># We only have one &quot;observation&quot; for each realization, so</span>
<span class="c1"># only one row pr. realization is returned.</span>
<span class="n">misfit</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">mismatch</span><span class="p">(</span><span class="n">ens</span><span class="p">)</span>

<span class="c1"># Sort ascending by L1 (absolute error) and print the realization</span>
<span class="c1"># indices of the first five:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">misfit</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;L1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">()[</span><span class="s1">&#39;REAL&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
<span class="c1"># Will return f.ex:</span>
<span class="c1">#   [ 38  26 100  71  57]</span>
</pre></div>
</div>
<p>For comparisons with single measured values (recommended for history
matching), use the YAML syntax:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">smry</span><span class="p">:</span>
<span class="w">  </span><span class="c1"># Mandatory elements per entry: key and observations</span>
<span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">key</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">WBP4:OP_1</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain"># This is a global comment regarding this set of observations</span>
<span class="w">  </span><span class="nt">comment</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Shut-in</span><span class="nv"> </span><span class="s">pressures</span><span class="nv"> </span><span class="s">converted</span><span class="nv"> </span><span class="s">from</span><span class="nv"> </span><span class="s">well</span><span class="nv"> </span><span class="s">head</span><span class="nv"> </span><span class="s">conditions&quot;</span>
<span class="w">  </span><span class="nt">observations</span><span class="p">:</span>
<span class="w">     </span><span class="c1"># Mandatory elements per entry in ecl_vector observations: value, error, date</span>
<span class="w">     </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="nv">251</span><span class="p p-Indicator">,</span><span class="nt"> error</span><span class="p">:</span><span class="w"> </span><span class="nv">4</span><span class="p p-Indicator">,</span><span class="nt"> date</span><span class="p">:</span><span class="w"> </span><span class="nv">2001-01-01</span><span class="p p-Indicator">}</span>
<span class="w">     </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="nv">251</span><span class="p p-Indicator">,</span><span class="nt"> error</span><span class="p">:</span><span class="w"> </span><span class="nv">10</span><span class="p p-Indicator">,</span><span class="nt"> date</span><span class="p">:</span><span class="w"> </span><span class="nv">2002-01-01</span><span class="p p-Indicator">}</span>
<span class="w">     </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="nv">251</span><span class="p p-Indicator">,</span><span class="nt"> error</span><span class="p">:</span><span class="w"> </span><span class="nv">10</span><span class="p p-Indicator">,</span><span class="nt"> date</span><span class="p">:</span><span class="w"> </span><span class="nv">2003-01-01</span><span class="p p-Indicator">,</span>
<span class="nt">        comment</span><span class="p">:</span><span class="w"> </span><span class="nv">First measurement after sensor drift correction</span><span class="p p-Indicator">}</span>
</pre></div>
</div>
</section>
<section id="representative-realizations">
<h2>Representative realizations<a class="headerlink" href="#representative-realizations" title="Permalink to this heading"></a></h2>
<p>It is possible to utilize the observation support for calculating
similarity between realizations. An example of this is to create a
“mean” realization by use of the aggregation functionality (or p10,
p90 etc.) and then rank the ensemble members by how similar they are
to this aggregated realization. It is possible to pick certain summary
data from the virtual realization as “observations”, and calculate
mismatches. For this, a utility function <code class="docutils literal notranslate"><span class="pre">load_smry()</span></code> is provided
by the Observation object to load “virtual” observations from an
existing realization. If you then use the Observation object to
compute mismatches, and then rank realizations by the mismatch, you
can pick the realization that is closest to your statistics of choice.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load an ensemble we want to analyze</span>
<span class="n">ens</span> <span class="o">=</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">ScratchEnsemble</span><span class="p">(</span><span class="s1">&#39;hmensemble&#39;</span><span class="p">,</span>
        <span class="s1">&#39;/scratch/foo/something/realization-*/iter-3&#39;</span><span class="p">)</span>
<span class="n">ens</span><span class="o">.</span><span class="n">load_smry</span><span class="p">(</span><span class="n">column_keys</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;FOPT&#39;</span><span class="p">],</span> <span class="n">time_index</span><span class="o">=</span><span class="s1">&#39;yearly&#39;</span><span class="p">)</span>

<span class="c1"># Calculate a &quot;mean&quot; realization</span>
<span class="n">mean</span> <span class="o">=</span> <span class="n">ens</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>

<span class="c1"># Create an empty observation object</span>
<span class="n">obs</span> <span class="o">=</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">Observations</span><span class="p">({})</span>

<span class="c1"># Load data from the mean realization as virtual observations:</span>
<span class="n">obs</span><span class="o">.</span><span class="n">load_smry</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="s1">&#39;FOPT&#39;</span><span class="p">,</span> <span class="n">time_index</span><span class="o">=</span><span class="s1">&#39;yearly&#39;</span><span class="p">)</span>

<span class="c1"># Calculate the difference between the ensemble members and the</span>
<span class="c1"># mean realization:</span>
<span class="n">mis</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">mismatch</span><span class="p">(</span><span class="n">ens</span><span class="p">)</span>

<span class="c1"># Group mismatch data by realization, and pick the realization</span>
<span class="c1"># index with the smallest sum of squared errors (&#39;L2&#39;)</span>
<span class="n">closest_to_mean</span> <span class="o">=</span> <span class="n">mis</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;REAL&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numeric_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="s1">&#39;L2&#39;</span><span class="p">]</span>\
                                     <span class="o">.</span><span class="n">sort_values</span><span class="p">()</span>\
                                     <span class="o">.</span><span class="n">index</span>\
                                     <span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</section>
<section id="custom-compute-functions-for-each-realization">
<h2>Custom compute functions for each realization<a class="headerlink" href="#custom-compute-functions-for-each-realization" title="Permalink to this heading"></a></h2>
<p>If you have a custom Python function that works on Realization objects producing
some dataframe, you can have the Ensemble object apply this function to each
realization in turn (potentially in parallel).</p>
<p>Note that the same can be accomplished if you are able to produce the same
dataframe and export it to a CSV file in every realization, and then use
<code class="docutils literal notranslate"><span class="pre">load_csv()</span></code> on the ensemble object. But this requires the CSV file to be
precomputed and dumped in every realization directory, which is not always
practical.</p>
<p>Assume first we have a function that is able to produce such a table when given
a <code class="docutils literal notranslate"><span class="pre">ScratchRealization</span></code> object (the function can choose freely what information
in the realization object to use, potentially only the directory).</p>
<table class="docutils align-default" id="id1">
<caption><span class="caption-text">Example data from one realization.</span><a class="headerlink" href="#id1" title="Permalink to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>ZONE</p></th>
<th class="head"><p>PORV</p></th>
<th class="head"><p>VOLUME</p></th>
<th class="head"><p>Z</p></th>
<th class="head"><p>PERMX</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>LowerReek</p></td>
<td><p>91526392.0</p></td>
<td><p>504504371.3</p></td>
<td><p>1595.7</p></td>
<td><p>1079.4</p></td>
</tr>
<tr class="row-odd"><td><p>MidReek</p></td>
<td><p>157574096.0</p></td>
<td><p>938721683.9</p></td>
<td><p>1585.9</p></td>
<td><p>877.4</p></td>
</tr>
<tr class="row-even"><td><p>UpperReek</p></td>
<td><p>142346336.0</p></td>
<td><p>1036154565.6</p></td>
<td><p>1570.7</p></td>
<td><p>493.1</p></td>
</tr>
</tbody>
</table>
<p>where PORV and VOLUME are sums over each zone, Z is the minimum (thus apex pr.
zone) and PERMX is an arithmetic mean. In the language of <a class="reference external" href="https://equinor.github.io/res2df/">res2df</a> this could be done with a code like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">res2df</span> <span class="kn">import</span> <span class="n">grid</span><span class="p">,</span> <span class="n">ResdataFiles</span>

<span class="n">resdatafiles</span> <span class="o">=</span> <span class="n">ResdataFiles</span><span class="p">(</span><span class="s1">&#39;MYDATADECK.DATA&#39;</span><span class="p">)</span>  <span class="c1"># There is a file zones.lyr alongside this.</span>
<span class="n">grid_df</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">df</span><span class="p">(</span><span class="n">resdatafiles</span><span class="p">)</span>  <span class="c1"># Produce a dataframe with one row pr. cell</span>
<span class="n">my_aggregators</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;PORV&#39;</span><span class="p">:</span> <span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="s1">&#39;VOLUME&#39;</span><span class="p">:</span> <span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;PERMX&#39;</span><span class="p">:</span> <span class="s1">&#39;mean&#39;</span><span class="p">}</span>
<span class="n">stats_df</span> <span class="o">=</span> <span class="n">grid_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;ZONE&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">my_aggregators</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">stats_df</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">ScratchRealization</span></code> objects contain the methods <code class="docutils literal notranslate"><span class="pre">runpath()</span></code> which will give
the full path to the directory  the realization resides in, this can be used
freely by your function.  For easier coupling with res2df, the function
<code class="docutils literal notranslate"><span class="pre">get_resdatafiles()</span></code> is provided.</p>
<p>To be able to inject the res2df lines above into the API of fmu.ensemble and the
<a class="reference internal" href="fmu.ensemble.html#fmu.ensemble.ensemble.ScratchEnsemble.apply" title="fmu.ensemble.ensemble.ScratchEnsemble.apply"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code></a> function, we
need to to put it into a wrapper function.  This wrapper function will always
receive a Realization object as a named argument, and it must return a
dataframe. The wrapper function can look like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">res2df</span> <span class="kn">import</span> <span class="n">grid</span><span class="p">,</span> <span class="n">ResdataFiles</span>

<span class="k">def</span> <span class="nf">my_realization_stats</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;A custom function for performing a particular calculation</span>
<span class="sd">   on every realization</span>

<span class="sd">   Args:</span>
<span class="sd">      args (dict): A dictionary with parameters to my custom function.</span>
<span class="sd">          The keys &#39;realization&#39; and &#39;localpath&#39; are reserved for fmu.ensemble.&quot;&quot;&quot;</span>
   <span class="n">realization</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s2">&quot;realization&quot;</span><span class="p">]</span>  <span class="c1"># Provided by fmu.ensemble apply()</span>
   <span class="n">resdatafiles</span> <span class="o">=</span> <span class="n">realization</span><span class="o">.</span><span class="n">get_resdatafiles</span><span class="p">()</span>
   <span class="n">grid_df</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">df</span><span class="p">(</span><span class="n">resdatafiles</span><span class="p">)</span>
   <span class="n">my_aggregators</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;PORV&#39;</span><span class="p">:</span> <span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="s1">&#39;VOLUME&#39;</span><span class="p">:</span> <span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;PERMX&#39;</span><span class="p">:</span> <span class="s1">&#39;mean&#39;</span><span class="p">}</span>
   <span class="n">stats_df</span> <span class="o">=</span> <span class="n">grid_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;ZONE&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">my_aggregators</span><span class="p">)</span>
   <span class="k">return</span> <span class="n">stats_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>  <span class="c1"># Zone names are in the index, lost if not reset.</span>
</pre></div>
</div>
<p>You are free to code your wrapper function in a way that suits both usage in apply() and
interactive usage. Your wrapper function can perform differently for example if the
“realization” key is not existing in the args dictionary given as input.</p>
<p>When this function is defined, and your ensemble is initialized, you can call
this function on every realization as in the following (this would work on
EnsembleSets also):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fmu.ensemble</span> <span class="kn">import</span> <span class="n">ScratchEnsemble</span>

<span class="n">ensemble</span> <span class="o">=</span> <span class="n">ScratchEnsemble</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">,</span> <span class="s2">&quot;testcase/realization-*/iter-0&quot;</span><span class="p">)</span>
<span class="n">ensemble</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">my_realization_stats</span><span class="p">,</span> <span class="n">localpath</span><span class="o">=</span><span class="s2">&quot;zonestats.csv&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>For interactive test-runs on single realizations, you can run
<code class="docutils literal notranslate"><span class="pre">my_realization_stats({&quot;realization&quot;:</span> <span class="pre">ens[0])</span></code> if <code class="docutils literal notranslate"><span class="pre">ens</span></code> is a ScratchEnsemble
object.</p>
<p>After the <code class="docutils literal notranslate"><span class="pre">apply()</span></code> operation is performed above, the data for each
realization resides  in each realization object by the key <em>zonestats.csv</em>.  We
can obtain all the data for all realizations (aggretated vertically by
concatenation) by asking <code class="docutils literal notranslate"><span class="pre">ensemble.get_df(&quot;zonestats.csv&quot;)</span></code>. Further
aggregation to the ensemble level can be sone with the <a class="reference internal" href="fmu.ensemble.html#fmu.ensemble.ensemble.ScratchEnsemble.agg" title="fmu.ensemble.ensemble.ScratchEnsemble.agg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">agg()</span></code></a> function which returns a
VirtualRealization object from an Ensemble object. If we want only the
aggregated table for our particular custom function, we can aggregate the
ensemble only for that particular datatype:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">mean_realization</span> <span class="o">=</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="n">keylist</span><span class="o">=</span><span class="s2">&quot;zonestats.csv&quot;</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="n">mean_realization</span><span class="o">.</span><span class="n">get_df</span><span class="p">(</span><span class="s2">&quot;zonestats.csv&quot;</span><span class="p">)</span>
<span class="n">Out</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
        <span class="n">ZONE</span>        <span class="n">PERMX</span>        <span class="n">VOLUME</span>            <span class="n">Z</span>         <span class="n">PORV</span>
<span class="mi">0</span>  <span class="n">LowerReek</span>  <span class="mf">1105.552718</span>  <span class="mf">6.070259e+08</span>  <span class="mf">1599.113406</span>  <span class="mf">109885776.0</span>
<span class="mi">1</span>    <span class="n">MidReek</span>   <span class="mf">966.315122</span>  <span class="mf">9.608399e+08</span>  <span class="mf">1586.559663</span>  <span class="mf">161875872.0</span>
<span class="mi">2</span>  <span class="n">UpperReek</span>   <span class="mf">592.824625</span>  <span class="mf">1.028779e+09</span>  <span class="mf">1571.164775</span>  <span class="mf">148655376.0</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="concepts.html" class="btn btn-neutral float-left" title="Concepts in fmu-ensemble" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="modules.html" class="btn btn-neutral float-right" title="API for fmu.ensemble" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Equinor.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>  

  <style>
    /* Sidebar header (and topbar for mobile) */
    .wy-side-nav-search, .wy-nav-top {
      background: #ff1243;
    }
    /* Sidebar */
    .wy-nav-side {
      background: #474747;
    }
    .wy-side-nav-search > div.version {
      color: white;
￼   }
  </style>


</body>
</html>